<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>内存泄漏检测工具 - API密钥测试器</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            padding: 30px;
        }
        
        .control-panel {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #4CAF50;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .stat-card.warning {
            border-left-color: #FF9800;
        }
        
        .stat-card.danger {
            border-left-color: #f44336;
        }
        
        .stat-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        
        .chart-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }
        
        .chart {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 8px;
            position: relative;
            background: #fafafa;
        }
        
        .log-container {
            background: #1e1e1e;
            color: #fff;
            border-radius: 12px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .log-info {
            background: rgba(33, 150, 243, 0.2);
            border-left: 3px solid #2196F3;
        }
        
        .log-warning {
            background: rgba(255, 152, 0, 0.2);
            border-left: 3px solid #FF9800;
        }
        
        .log-error {
            background: rgba(244, 67, 54, 0.2);
            border-left: 3px solid #f44336;
        }
        
        .log-success {
            background: rgba(76, 175, 80, 0.2);
            border-left: 3px solid #4CAF50;
        }
        
        .recommendations {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 1px solid #ffc107;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .recommendations h3 {
            margin-top: 0;
            color: #856404;
        }
        
        .recommendation {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #ffc107;
        }
        
        .recommendation.critical {
            border-left-color: #dc3545;
            background: #fff5f5;
        }
        
        .recommendation.warning {
            border-left-color: #fd7e14;
            background: #fff8f0;
        }
        
        .recommendation-title {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .recommendation-actions {
            margin-top: 10px;
        }
        
        .recommendation-actions ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-monitoring {
            background: #4CAF50;
            animation: pulse 2s infinite;
        }
        
        .status-stopped {
            background: #ccc;
        }
        
        .status-warning {
            background: #FF9800;
            animation: pulse 2s infinite;
        }
        
        .status-error {
            background: #f44336;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔍 内存泄漏检测工具</h1>
            <p>实时监控API密钥测试器的内存使用情况，检测潜在的内存泄漏问题</p>
        </div>
        
        <div class="content">
            <!-- 控制面板 -->
            <div class="control-panel">
                <button id="startBtn" class="btn btn-primary">
                    <span class="status-indicator status-stopped"></span>
                    开始监控
                </button>
                <button id="stopBtn" class="btn btn-secondary" disabled>
                    停止监控
                </button>
                <button id="clearBtn" class="btn btn-warning">
                    清除数据
                </button>
                <button id="reportBtn" class="btn btn-secondary">
                    生成报告
                </button>
                <button id="testLeakBtn" class="btn btn-danger">
                    模拟内存泄漏
                </button>
            </div>
            
            <!-- 实时统计 -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-title">当前内存使用</div>
                    <div class="stat-value" id="currentMemory">0 MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">内存增长</div>
                    <div class="stat-value" id="memoryGrowth">0 MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">监控时长</div>
                    <div class="stat-value" id="monitoringDuration">0 秒</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">泄漏风险</div>
                    <div class="stat-value" id="leakRisk">低</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">DOM节点数</div>
                    <div class="stat-value" id="domNodes">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">样本数量</div>
                    <div class="stat-value" id="sampleCount">0</div>
                </div>
            </div>
            
            <!-- 内存使用图表 -->
            <div class="chart-container">
                <div class="chart-title">📊 内存使用趋势</div>
                <canvas id="memoryChart" class="chart"></canvas>
            </div>
            
            <!-- 建议和警告 -->
            <div id="recommendationsContainer" class="recommendations" style="display: none;">
                <h3>🚨 检测结果和建议</h3>
                <div id="recommendationsList"></div>
            </div>
            
            <!-- 实时日志 -->
            <div class="chart-container">
                <div class="chart-title">📝 实时监控日志</div>
                <div id="logContainer" class="log-container">
                    <div class="log-entry log-info">
                        [INFO] 内存泄漏检测工具已加载，点击"开始监控"开始检测
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 直接在HTML中定义MemoryLeakDetector类
        class MemoryLeakDetector {
            constructor() {
                this.config = {
                    samplingInterval: 1000,        // 采样间隔1秒
                    maxSamples: 300,              // 最多保存300个样本(5分钟)
                    leakThreshold: 0.1,           // 泄漏阈值10%
                    growthThreshold: 50 * 1024 * 1024, // 增长阈值50MB
                    stabilityWindow: 30,          // 稳定性窗口30秒
                    alertThreshold: 100 * 1024 * 1024 // 警告阈值100MB
                };
                
                this.samples = [];
                this.isMonitoring = false;
                this.monitoringTimer = null;
                this.listeners = [];
                this.baseline = null;
                
                console.log('[MemoryLeakDetector] 内存泄漏检测器已初始化');
            }
            
            startMonitoring() {
                if (this.isMonitoring) {
                    console.warn('[MemoryLeakDetector] 已在监控中');
                    return;
                }
                
                this.isMonitoring = true;
                this.samples = [];
                this.baseline = this.getCurrentMemoryUsage();
                
                this.monitoringTimer = setInterval(() => {
                    this.collectSample();
                }, this.config.samplingInterval);
                
                console.log('[MemoryLeakDetector] 开始内存监控');
                this.notifyListeners('monitoring_started', { baseline: this.baseline });
            }
            
            stopMonitoring() {
                if (!this.isMonitoring) {
                    return;
                }
                
                this.isMonitoring = false;
                
                if (this.monitoringTimer) {
                    clearInterval(this.monitoringTimer);
                    this.monitoringTimer = null;
                }
                
                const analysis = this.analyzeMemoryUsage();
                
                console.log('[MemoryLeakDetector] 停止内存监控');
                this.notifyListeners('monitoring_stopped', analysis);
                
                return analysis;
            }
            
            collectSample() {
                const sample = {
                    timestamp: Date.now(),
                    memory: this.getCurrentMemoryUsage(),
                    domNodes: this.getDOMNodeCount()
                };
                
                this.samples.push(sample);
                
                if (this.samples.length > this.config.maxSamples) {
                    this.samples.shift();
                }
                
                this.checkForAnomalies(sample);
                this.notifyListeners('sample_collected', sample);
            }
            
            getCurrentMemoryUsage() {
                const memInfo = {
                    used: 0,
                    total: 0,
                    limit: 0,
                    available: 0
                };
                
                if (typeof performance !== 'undefined' && performance.memory) {
                    memInfo.used = performance.memory.usedJSHeapSize;
                    memInfo.total = performance.memory.totalJSHeapSize;
                    memInfo.limit = performance.memory.jsHeapSizeLimit;
                    memInfo.available = memInfo.limit - memInfo.used;
                }
                
                return memInfo;
            }
            
            getDOMNodeCount() {
                if (typeof document !== 'undefined') {
                    return document.getElementsByTagName('*').length;
                }
                return 0;
            }
            
            checkForAnomalies(sample) {
                if (this.samples.length < 10) return;
                
                const recentSamples = this.samples.slice(-10);
                const memoryGrowth = sample.memory.used - recentSamples[0].memory.used;
                
                if (memoryGrowth > this.config.growthThreshold) {
                    this.notifyListeners('anomaly_detected', {
                        type: 'rapid_growth',
                        growth: memoryGrowth,
                        sample: sample
                    });
                }
                
                if (sample.memory.used > this.config.alertThreshold) {
                    this.notifyListeners('anomaly_detected', {
                        type: 'high_usage',
                        usage: sample.memory.used,
                        sample: sample
                    });
                }
            }
            
            analyzeMemoryUsage() {
                if (this.samples.length < 2) {
                    return {
                        hasLeak: false,
                        message: '样本数据不足，无法分析',
                        recommendations: []
                    };
                }
                
                const analysis = {
                    duration: this.samples[this.samples.length - 1].timestamp - this.samples[0].timestamp,
                    totalSamples: this.samples.length,
                    memoryStats: this.calculateMemoryStats(),
                    leakDetection: this.detectMemoryLeak(),
                    recommendations: []
                };
                
                analysis.recommendations = this.generateRecommendations(analysis);
                return analysis;
            }
            
            calculateMemoryStats() {
                const memoryValues = this.samples.map(s => s.memory.used);
                const domCounts = this.samples.map(s => s.domNodes);
                
                return {
                    memory: {
                        min: Math.min(...memoryValues),
                        max: Math.max(...memoryValues),
                        avg: memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length,
                        growth: memoryValues[memoryValues.length - 1] - memoryValues[0],
                        trend: this.calculateTrend(memoryValues)
                    },
                    domNodes: {
                        min: Math.min(...domCounts),
                        max: Math.max(...domCounts),
                        avg: domCounts.reduce((a, b) => a + b, 0) / domCounts.length,
                        growth: domCounts[domCounts.length - 1] - domCounts[0]
                    }
                };
            }
            
            detectMemoryLeak() {
                const memoryValues = this.samples.map(s => s.memory.used);
                const trend = this.calculateTrend(memoryValues);
                const growth = memoryValues[memoryValues.length - 1] - memoryValues[0];
                const duration = this.samples[this.samples.length - 1].timestamp - this.samples[0].timestamp;
                
                const leakRate = (growth / (1024 * 1024)) / (duration / 60000);
                const hasLeak = trend > this.config.leakThreshold && leakRate > 1;
                
                return {
                    hasLeak,
                    leakRate,
                    trend,
                    growth,
                    confidence: this.calculateLeakConfidence(trend, leakRate, memoryValues)
                };
            }
            
            calculateTrend(values) {
                if (values.length < 2) return 0;
                
                const n = values.length;
                const sumX = (n * (n - 1)) / 2;
                const sumY = values.reduce((a, b) => a + b, 0);
                const sumXY = values.reduce((sum, y, x) => sum + x * y, 0);
                const sumX2 = values.reduce((sum, _, x) => sum + x * x, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                return slope;
            }
            
            calculateLeakConfidence(trend, leakRate, values) {
                let confidence = 0;
                
                if (trend > 0.5) confidence += 0.4;
                else if (trend > 0.2) confidence += 0.2;
                
                if (leakRate > 5) confidence += 0.4;
                else if (leakRate > 2) confidence += 0.2;
                
                const stability = this.calculateStability(values);
                if (stability < 0.1) confidence += 0.2;
                
                return Math.min(confidence, 1.0);
            }
            
            calculateStability(values) {
                if (values.length < 2) return 1;
                
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);
                
                return stdDev / mean;
            }
            
            generateRecommendations(analysis) {
                const recommendations = [];
                
                if (analysis.leakDetection.hasLeak) {
                    recommendations.push({
                        type: 'critical',
                        message: '检测到内存泄漏',
                        details: `泄漏率: ${analysis.leakDetection.leakRate.toFixed(2)} MB/分钟`,
                        actions: [
                            '检查事件监听器是否正确移除',
                            '检查定时器是否正确清理',
                            '检查闭包引用是否存在循环引用',
                            '使用浏览器开发工具进行详细分析'
                        ]
                    });
                }
                
                if (analysis.memoryStats.memory.growth > 50 * 1024 * 1024) {
                    recommendations.push({
                        type: 'warning',
                        message: '内存使用增长较大',
                        details: `增长: ${(analysis.memoryStats.memory.growth / 1024 / 1024).toFixed(2)} MB`,
                        actions: [
                            '检查是否有大量数据缓存',
                            '考虑实现数据分页或清理机制',
                            '优化数据结构和算法'
                        ]
                    });
                }
                
                return recommendations;
            }
            
            addListener(listener) {
                this.listeners.push(listener);
            }
            
            removeListener(listener) {
                const index = this.listeners.indexOf(listener);
                if (index > -1) {
                    this.listeners.splice(index, 1);
                }
            }
            
            notifyListeners(event, data) {
                this.listeners.forEach(listener => {
                    try {
                        listener(event, data);
                    } catch (error) {
                        console.error('[MemoryLeakDetector] 监听器错误:', error);
                    }
                });
            }
            
            generateReport() {
                const analysis = this.analyzeMemoryUsage();
                
                return {
                    timestamp: new Date().toISOString(),
                    summary: {
                        isMonitoring: this.isMonitoring,
                        duration: analysis.duration,
                        samplesCount: analysis.totalSamples,
                        hasLeak: analysis.leakDetection?.hasLeak || false,
                        leakRate: analysis.leakDetection?.leakRate || 0
                    },
                    details: analysis,
                    samples: this.samples.slice(-50)
                };
            }
            
            cleanup() {
                this.stopMonitoring();
                this.samples = [];
                this.listeners = [];
                console.log('[MemoryLeakDetector] 资源已清理');
            }
        }
    </script>
    <script>
        
        class MemoryLeakTestUI {
            constructor() {
                this.detector = new MemoryLeakDetector();
                this.chart = null;
                this.chartData = [];
                this.simulatedLeaks = [];
                
                this.initializeUI();
                this.setupEventListeners();
                this.setupDetectorListeners();
                
                this.log('内存泄漏检测工具已初始化', 'info');
            }
            
            initializeUI() {
                // 初始化图表
                this.initChart();
                
                // 更新初始状态
                this.updateStats();
            }
            
            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startMonitoring();
                });
                
                document.getElementById('stopBtn').addEventListener('click', () => {
                    this.stopMonitoring();
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearData();
                });
                
                document.getElementById('reportBtn').addEventListener('click', () => {
                    this.generateReport();
                });
                
                document.getElementById('testLeakBtn').addEventListener('click', () => {
                    this.simulateMemoryLeak();
                });
            }
            
            setupDetectorListeners() {
                this.detector.addListener((event, data) => {
                    switch (event) {
                        case 'monitoring_started':
                            this.log('开始内存监控', 'success');
                            this.updateMonitoringStatus(true);
                            break;
                            
                        case 'monitoring_stopped':
                            this.log('停止内存监控', 'info');
                            this.updateMonitoringStatus(false);
                            this.showAnalysisResults(data);
                            break;
                            
                        case 'sample_collected':
                            this.updateChart(data);
                            this.updateStats(data);
                            break;
                            
                        case 'anomaly_detected':
                            this.handleAnomaly(data);
                            break;
                    }
                });
            }
            
            startMonitoring() {
                this.detector.startMonitoring();
            }
            
            stopMonitoring() {
                this.detector.stopMonitoring();
            }
            
            clearData() {
                this.chartData = [];
                this.updateChart();
                this.updateStats();
                this.hideRecommendations();
                this.log('数据已清除', 'info');
            }
            
            generateReport() {
                const report = this.detector.generateReport();
                this.downloadReport(report);
                this.log('报告已生成并下载', 'success');
            }
            
            simulateMemoryLeak() {
                // 模拟内存泄漏
                const leak = {
                    data: new Array(100000).fill('memory leak simulation'),
                    timer: setInterval(() => {
                        leak.data.push(new Array(1000).fill(Math.random()));
                    }, 100)
                };
                
                this.simulatedLeaks.push(leak);
                this.log('已启动内存泄漏模拟 (每100ms增加1MB)', 'warning');
                
                // 10秒后自动停止
                setTimeout(() => {
                    clearInterval(leak.timer);
                    this.log('内存泄漏模拟已停止', 'info');
                }, 10000);
            }
            
            updateMonitoringStatus(isMonitoring) {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const indicator = startBtn.querySelector('.status-indicator');
                
                if (isMonitoring) {
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    startBtn.innerHTML = '<span class="status-indicator status-monitoring"></span>监控中...';
                    indicator.className = 'status-indicator status-monitoring';
                } else {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    startBtn.innerHTML = '<span class="status-indicator status-stopped"></span>开始监控';
                    indicator.className = 'status-indicator status-stopped';
                }
            }
            
            updateStats(sample = null) {
                const currentMemoryEl = document.getElementById('currentMemory');
                const memoryGrowthEl = document.getElementById('memoryGrowth');
                const durationEl = document.getElementById('monitoringDuration');
                const leakRiskEl = document.getElementById('leakRisk');
                const domNodesEl = document.getElementById('domNodes');
                const sampleCountEl = document.getElementById('sampleCount');
                
                if (sample) {
                    // 更新当前内存
                    const currentMB = (sample.memory.used / 1024 / 1024).toFixed(1);
                    currentMemoryEl.textContent = `${currentMB} MB`;
                    
                    // 更新DOM节点数
                    domNodesEl.textContent = sample.domNodes.toLocaleString();
                    
                    // 计算内存增长
                    if (this.detector.baseline) {
                        const growth = sample.memory.used - this.detector.baseline.used;
                        const growthMB = (growth / 1024 / 1024).toFixed(1);
                        memoryGrowthEl.textContent = `${growthMB} MB`;
                        
                        // 更新增长状态
                        const growthCard = memoryGrowthEl.closest('.stat-card');
                        if (growth > 50 * 1024 * 1024) {
                            growthCard.className = 'stat-card danger';
                        } else if (growth > 20 * 1024 * 1024) {
                            growthCard.className = 'stat-card warning';
                        } else {
                            growthCard.className = 'stat-card';
                        }
                    }
                    
                    // 更新监控时长
                    if (this.detector.samples.length > 0) {
                        const duration = (sample.timestamp - this.detector.samples[0].timestamp) / 1000;
                        durationEl.textContent = `${Math.floor(duration)} 秒`;
                    }
                    
                    // 更新样本数量
                    sampleCountEl.textContent = this.detector.samples.length.toLocaleString();
                    
                    // 评估泄漏风险
                    this.updateLeakRisk(leakRiskEl);
                } else {
                    // 重置显示
                    currentMemoryEl.textContent = '0 MB';
                    memoryGrowthEl.textContent = '0 MB';
                    durationEl.textContent = '0 秒';
                    leakRiskEl.textContent = '低';
                    domNodesEl.textContent = '0';
                    sampleCountEl.textContent = '0';
                }
            }
            
            updateLeakRisk(element) {
                if (this.detector.samples.length < 10) {
                    element.textContent = '评估中';
                    element.closest('.stat-card').className = 'stat-card';
                    return;
                }
                
                const analysis = this.detector.analyzeMemoryUsage();
                const leakDetection = analysis.leakDetection;
                
                if (leakDetection.hasLeak) {
                    if (leakDetection.confidence > 0.7) {
                        element.textContent = '高';
                        element.closest('.stat-card').className = 'stat-card danger';
                    } else {
                        element.textContent = '中';
                        element.closest('.stat-card').className = 'stat-card warning';
                    }
                } else {
                    element.textContent = '低';
                    element.closest('.stat-card').className = 'stat-card';
                }
            }
            
            initChart() {
                const canvas = document.getElementById('memoryChart');
                const ctx = canvas.getContext('2d');
                
                // 设置canvas尺寸
                canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                this.chart = { canvas, ctx };
                this.drawChart();
            }
            
            updateChart(sample = null) {
                if (sample) {
                    this.chartData.push({
                        timestamp: sample.timestamp,
                        memory: sample.memory.used,
                        domNodes: sample.domNodes
                    });
                    
                    // 保持最多300个数据点
                    if (this.chartData.length > 300) {
                        this.chartData.shift();
                    }
                }
                
                this.drawChart();
            }
            
            drawChart() {
                if (!this.chart) return;
                
                const { ctx, canvas } = this.chart;
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                // 清空画布
                ctx.clearRect(0, 0, width, height);
                
                if (this.chartData.length === 0) {
                    // 显示空状态
                    ctx.fillStyle = '#999';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('暂无数据', width / 2, height / 2);
                    return;
                }
                
                // 计算数据范围
                const memoryValues = this.chartData.map(d => d.memory);
                const minMemory = Math.min(...memoryValues);
                const maxMemory = Math.max(...memoryValues);
                const memoryRange = maxMemory - minMemory || 1;
                
                // 绘制网格
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                
                // 垂直网格线
                for (let i = 0; i <= 10; i++) {
                    const x = (width / 10) * i;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // 水平网格线
                for (let i = 0; i <= 5; i++) {
                    const y = (height / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // 绘制内存使用曲线
                if (this.chartData.length > 1) {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    this.chartData.forEach((point, index) => {
                        const x = (index / (this.chartData.length - 1)) * width;
                        const y = height - ((point.memory - minMemory) / memoryRange) * height;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                }
                
                // 绘制Y轴标签
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                
                for (let i = 0; i <= 5; i++) {
                    const value = minMemory + (memoryRange / 5) * (5 - i);
                    const y = (height / 5) * i + 5;
                    ctx.fillText(`${(value / 1024 / 1024).toFixed(1)}MB`, width - 5, y);
                }
            }
            
            handleAnomaly(data) {
                switch (data.type) {
                    case 'rapid_growth':
                        this.log(`⚠️ 检测到内存快速增长: ${(data.growth / 1024 / 1024).toFixed(1)}MB`, 'warning');
                        break;
                        
                    case 'high_usage':
                        this.log(`🚨 内存使用过高: ${(data.usage / 1024 / 1024).toFixed(1)}MB`, 'error');
                        break;
                }
            }
            
            showAnalysisResults(analysis) {
                const container = document.getElementById('recommendationsContainer');
                const list = document.getElementById('recommendationsList');
                
                if (!analysis.recommendations || analysis.recommendations.length === 0) {
                    container.style.display = 'none';
                    return;
                }
                
                list.innerHTML = '';
                
                analysis.recommendations.forEach(rec => {
                    const div = document.createElement('div');
                    div.className = `recommendation ${rec.type}`;
                    
                    div.innerHTML = `
                        <div class="recommendation-title">${rec.message}</div>
                        <div>${rec.details}</div>
                        <div class="recommendation-actions">
                            <strong>建议操作:</strong>
                            <ul>
                                ${rec.actions.map(action => `<li>${action}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                    
                    list.appendChild(div);
                });
                
                container.style.display = 'block';
            }
            
            hideRecommendations() {
                document.getElementById('recommendationsContainer').style.display = 'none';
            }
            
            downloadReport(report) {
                const blob = new Blob([JSON.stringify(report, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `memory-leak-report-${new Date().toISOString().slice(0, 19)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            log(message, type = 'info') {
                const container = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;
                
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
                
                // 保持最多100条日志
                while (container.children.length > 100) {
                    container.removeChild(container.firstChild);
                }
            }
        }
        
        // 初始化应用
        window.addEventListener('DOMContentLoaded', () => {
            try {
                new MemoryLeakTestUI();
            } catch (error) {
                console.error('初始化失败:', error);
                document.getElementById('logContainer').innerHTML += `
                    <div class="log-entry log-error">
                        [ERROR] 初始化失败: ${error.message}
                    </div>
                `;
            }
        });
    </script>
</body>
</html>
