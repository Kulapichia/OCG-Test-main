<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>优化模块Bug修复验证测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-header {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .console-output {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>🔧 优化模块Bug修复验证测试</h1>
    <p>此测试页面用于验证所有优化模块的bug修复效果，确保系统稳定性和性能。</p>

    <!-- 自适应并发控制器测试 -->
    <div class="test-section">
        <h2 class="test-header">1. 自适应并发控制器测试</h2>
        <button onclick="testAdaptiveConcurrency()">测试并发控制器</button>
        <div id="concurrency-results"></div>
        <div class="stats-grid" id="concurrency-stats"></div>
    </div>

    <!-- 智能重试管理器测试 -->
    <div class="test-section">
        <h2 class="test-header">2. 智能重试管理器测试</h2>
        <button onclick="testSmartRetry()">测试重试管理器</button>
        <div id="retry-results"></div>
        <div class="stats-grid" id="retry-stats"></div>
    </div>

    <!-- 增强内存管理器测试 -->
    <div class="test-section">
        <h2 class="test-header">3. 增强内存管理器测试</h2>
        <button onclick="testMemoryManager()">测试内存管理器</button>
        <div id="memory-results"></div>
        <div class="stats-grid" id="memory-stats"></div>
    </div>

    <!-- 高性能处理器测试 -->
    <div class="test-section">
        <h2 class="test-header">4. 高性能处理器测试</h2>
        <button onclick="testHighPerformanceProcessor()">测试批处理器</button>
        <div id="processor-results"></div>
        <div class="stats-grid" id="processor-stats"></div>
    </div>

    <!-- 网络优化器测试 -->
    <div class="test-section">
        <h2 class="test-header">5. 网络优化器测试</h2>
        <button onclick="testNetworkOptimizer()">测试网络优化器</button>
        <div id="network-results"></div>
        <div class="stats-grid" id="network-stats"></div>
    </div>

    <!-- 高速控制器集成测试 -->
    <div class="test-section">
        <h2 class="test-header">6. 高速控制器集成测试</h2>
        <button onclick="testHighSpeedController()">测试集成控制器</button>
        <div id="controller-results"></div>
        <div class="stats-grid" id="controller-stats"></div>
    </div>

    <!-- 综合压力测试 -->
    <div class="test-section">
        <h2 class="test-header">7. 综合压力测试</h2>
        <button onclick="runStressTest()">运行压力测试</button>
        <button onclick="runMemoryLeakTest()">内存泄漏测试</button>
        <div id="stress-results"></div>
        <div class="console-output" id="console-log"></div>
    </div>

    <!-- 加载优化模块 -->
    <script src="js/core/adaptiveConcurrencyManager.js"></script>
    <script src="js/core/smartRetryManager.js"></script>
    <script src="js/core/enhancedMemoryManager.js"></script>
    <script src="js/core/highPerformanceProcessor.js"></script>
    <script src="js/core/networkOptimizer.js"></script>
    <script src="js/core/highSpeedController.js"></script>

    <script>
        // 测试结果记录
        let testResults = {
            passed: 0,
            failed: 0,
            total: 0
        };

        // 控制台日志捕获
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        
        function captureConsoleOutput() {
            const consoleOutput = document.getElementById('console-log');
            
            console.log = function(...args) {
                originalConsoleLog.apply(console, args);
                consoleOutput.textContent += '[LOG] ' + args.join(' ') + '\n';
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            };
            
            console.error = function(...args) {
                originalConsoleError.apply(console, args);
                consoleOutput.textContent += '[ERROR] ' + args.join(' ') + '\n';
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            };
            
            console.warn = function(...args) {
                originalConsoleWarn.apply(console, args);
                consoleOutput.textContent += '[WARN] ' + args.join(' ') + '\n';
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            };
        }

        // 测试辅助函数
        function addTestResult(containerId, testName, passed, message, details = null) {
            const container = document.getElementById(containerId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            
            let content = `<strong>${testName}</strong>: ${message}`;
            if (details) {
                content += `<br><small>${details}</small>`;
            }
            resultDiv.innerHTML = content;
            
            container.appendChild(resultDiv);
            
            testResults.total++;
            if (passed) testResults.passed++;
            else testResults.failed++;
        }

        function addStats(containerId, stats) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            Object.entries(stats).forEach(([key, value]) => {
                const statCard = document.createElement('div');
                statCard.className = 'stat-card';
                statCard.innerHTML = `
                    <div class="stat-value">${value}</div>
                    <div class="stat-label">${key}</div>
                `;
                container.appendChild(statCard);
            });
        }

        // 1. 自适应并发控制器测试
        async function testAdaptiveConcurrency() {
            const resultsContainer = document.getElementById('concurrency-results');
            resultsContainer.innerHTML = '';
            
            try {
                // 测试基本功能
                if (typeof adaptiveConcurrencyManager === 'undefined') {
                    addTestResult('concurrency-results', '模块加载', false, '自适应并发控制器未加载');
                    return;
                }
                
                addTestResult('concurrency-results', '模块加载', true, '自适应并发控制器已加载');
                
                // 测试槽位获取和释放
                const slot = await adaptiveConcurrencyManager.acquireSlot();
                addTestResult('concurrency-results', '槽位获取', !!slot, slot ? `槽位ID: ${slot.id}` : '获取失败');
                
                if (slot) {
                    adaptiveConcurrencyManager.releaseSlot(slot, { success: true });
                    addTestResult('concurrency-results', '槽位释放', true, '成功释放槽位');
                }
                
                // 测试统计功能
                const stats = adaptiveConcurrencyManager.getDetailedStats();
                addTestResult('concurrency-results', '统计获取', !!stats, '统计数据获取成功');
                
                addStats('concurrency-stats', {
                    '当前并发': stats.concurrency?.current || 0,
                    '最大并发': stats.concurrency?.max || 0,
                    '总请求数': stats.performance?.totalRequests || 0,
                    '成功率': ((stats.performance?.successRate || 0) * 100).toFixed(1) + '%'
                });
                
            } catch (error) {
                addTestResult('concurrency-results', '异常处理', false, `测试出错: ${error.message}`);
            }
        }

        // 2. 智能重试管理器测试
        async function testSmartRetry() {
            const resultsContainer = document.getElementById('retry-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof smartRetryManager === 'undefined') {
                    addTestResult('retry-results', '模块加载', false, '智能重试管理器未加载');
                    return;
                }
                
                addTestResult('retry-results', '模块加载', true, '智能重试管理器已加载');
                
                // 测试成功场景
                let successCount = 0;
                const successTest = async () => {
                    successCount++;
                    if (successCount === 1) throw new Error('First attempt fails');
                    return { success: true };
                };
                
                const result = await smartRetryManager.executeWithRetry('test-key', successTest, { apiType: 'test' });
                addTestResult('retry-results', '重试成功', result.success, '第二次尝试成功');
                
                // 测试快速失败
                const fastFailTest = async () => {
                    const error = new Error('401 Unauthorized');
                    error.status = 401;
                    throw error;
                };
                
                try {
                    await smartRetryManager.executeWithRetry('test-key-2', fastFailTest, { apiType: 'test' });
                    addTestResult('retry-results', '快速失败', false, '应该快速失败但没有');
                } catch (error) {
                    addTestResult('retry-results', '快速失败', true, '401错误快速失败');
                }
                
                const stats = smartRetryManager.getStats();
                addStats('retry-stats', {
                    '总重试': stats.totalRetries || 0,
                    '成功重试': stats.successfulRetries || 0,
                    '快速失败': stats.fastFails || 0,
                    '熔断触发': stats.circuitBreakerTrips || 0
                });
                
            } catch (error) {
                addTestResult('retry-results', '异常处理', false, `测试出错: ${error.message}`);
            }
        }

        // 3. 增强内存管理器测试
        async function testMemoryManager() {
            const resultsContainer = document.getElementById('memory-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof enhancedMemoryManager === 'undefined') {
                    addTestResult('memory-results', '模块加载', false, '增强内存管理器未加载');
                    return;
                }
                
                addTestResult('memory-results', '模块加载', true, '增强内存管理器已加载');
                
                // 测试添加密钥
                for (let i = 0; i < 100; i++) {
                    enhancedMemoryManager.addKey({
                        key: `test-key-${i}`,
                        status: 'pending',
                        startTime: Date.now()
                    });
                }
                addTestResult('memory-results', '批量添加', true, '成功添加100个测试密钥');
                
                // 测试状态更新
                enhancedMemoryManager.updateKeyStatus('test-key-0', 'valid', { model: 'test-model' });
                addTestResult('memory-results', '状态更新', true, '成功更新密钥状态');
                
                // 测试批量获取
                const keys = enhancedMemoryManager.getKeysBatch({}, 10);
                addTestResult('memory-results', '批量获取', keys.length > 0, `获取到${keys.length}个密钥`);
                
                // 测试清理功能
                enhancedMemoryManager.performCleanup();
                addTestResult('memory-results', '内存清理', true, '内存清理执行完成');
                
                const stats = enhancedMemoryManager.getDetailedStats();
                addStats('memory-stats', {
                    '总密钥': stats.memory?.totalKeys || 0,
                    '活跃密钥': stats.memory?.activeKeys || 0,
                    '内存使用': stats.memory?.estimatedUsage || '0 MB',
                    '清理次数': stats.performance?.cleanupCount || 0
                });
                
            } catch (error) {
                addTestResult('memory-results', '异常处理', false, `测试出错: ${error.message}`);
            }
        }

        // 4. 高性能处理器测试
        async function testHighPerformanceProcessor() {
            const resultsContainer = document.getElementById('processor-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof highPerformanceProcessor === 'undefined') {
                    addTestResult('processor-results', '模块加载', false, '高性能处理器未加载');
                    return;
                }
                
                addTestResult('processor-results', '模块加载', true, '高性能处理器已加载');
                
                // 测试批处理
                const testData = Array.from({length: 50}, (_, i) => ({ id: i, value: `test-${i}` }));
                const processor = async (item, index) => {
                    await new Promise(resolve => setTimeout(resolve, 10)); // 模拟异步处理
                    return { processed: true, item, index };
                };
                
                const startTime = Date.now();
                const result = await highPerformanceProcessor.processBatch(testData, processor, { batchSize: 10 });
                const processingTime = Date.now() - startTime;
                
                addTestResult('processor-results', '批处理', result.totalProcessed > 0, 
                    `处理${result.totalProcessed}个项目，耗时${processingTime}ms`);
                
                // 测试UI更新
                highPerformanceProcessor.cacheResults([
                    { success: true, result: { status: 'valid', key: 'test-key' } }
                ]);
                addTestResult('processor-results', '结果缓存', true, '成功缓存处理结果');
                
                const stats = highPerformanceProcessor.getMetrics();
                addStats('processor-stats', {
                    '处理批次': stats.processedBatches || 0,
                    '平均批次时间': stats.avgBatchTime || '0ms',
                    'UI更新次数': stats.uiUpdateCount || 0,
                    '丢帧数': stats.droppedFrames || 0
                });
                
            } catch (error) {
                addTestResult('processor-results', '异常处理', false, `测试出错: ${error.message}`);
            }
        }

        // 5. 网络优化器测试
        async function testNetworkOptimizer() {
            const resultsContainer = document.getElementById('network-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof networkOptimizer === 'undefined') {
                    addTestResult('network-results', '模块加载', false, '网络优化器未加载');
                    return;
                }
                
                addTestResult('network-results', '模块加载', true, '网络优化器已加载');
                
                // 测试连接池
                const host = 'test.example.com';
                const connection = networkOptimizer.createConnection(host);
                addTestResult('network-results', '连接创建', !!connection, `连接ID: ${connection?.id}`);
                
                if (connection) {
                    networkOptimizer.releaseConnection(host, connection);
                    addTestResult('network-results', '连接释放', true, '连接成功释放到池中');
                }
                
                // 测试清理功能
                networkOptimizer.cleanupExpiredConnections();
                addTestResult('network-results', '连接清理', true, '过期连接清理完成');
                
                const stats = networkOptimizer.getDetailedStats();
                addStats('network-stats', {
                    '总请求': stats.requests?.total || 0,
                    '合并请求': stats.requests?.merged || 0,
                    '连接池命中': stats.connections?.poolHits || 0,
                    '网络错误': stats.performance?.networkErrors || 0
                });
                
            } catch (error) {
                addTestResult('network-results', '异常处理', false, `测试出错: ${error.message}`);
            }
        }

        // 6. 高速控制器集成测试
        async function testHighSpeedController() {
            const resultsContainer = document.getElementById('controller-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof highSpeedController === 'undefined') {
                    addTestResult('controller-results', '模块加载', false, '高速控制器未加载');
                    return;
                }
                
                addTestResult('controller-results', '模块加载', true, '高速控制器已加载');
                
                // 测试初始化
                await highSpeedController.initialize();
                addTestResult('controller-results', '初始化', highSpeedController.isInitialized, '控制器初始化完成');
                
                // 测试模块集成
                const stats = highSpeedController.getDetailedStats();
                const moduleCount = Object.keys(stats.modules || {}).length;
                addTestResult('controller-results', '模块集成', moduleCount > 0, `集成了${moduleCount}个优化模块`);
                
                // 测试配置更新
                highSpeedController.config.maxConcurrency = 20;
                addTestResult('controller-results', '配置更新', true, '成功更新配置参数');
                
                // 测试清理功能
                const originalCleanup = highSpeedController.cleanup;
                let cleanupCalled = false;
                highSpeedController.cleanup = function() {
                    cleanupCalled = true;
                    return originalCleanup.call(this);
                };
                
                addStats('controller-stats', {
                    '初始化状态': highSpeedController.isInitialized ? '是' : '否',
                    '运行状态': highSpeedController.isRunning ? '是' : '否',
                    '集成模块': moduleCount,
                    '最大并发': highSpeedController.config.maxConcurrency
                });
                
            } catch (error) {
                addTestResult('controller-results', '异常处理', false, `测试出错: ${error.message}`);
            }
        }

        // 7. 综合压力测试
        async function runStressTest() {
            const resultsContainer = document.getElementById('stress-results');
            resultsContainer.innerHTML = '<div class="test-info">正在运行压力测试...</div>';
            
            try {
                const startTime = Date.now();
                const promises = [];
                
                // 并发测试自适应并发控制器
                for (let i = 0; i < 100; i++) {
                    promises.push((async () => {
                        const slot = await adaptiveConcurrencyManager.acquireSlot();
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
                        adaptiveConcurrencyManager.releaseSlot(slot, { success: Math.random() > 0.1 });
                    })());
                }
                
                await Promise.all(promises);
                const totalTime = Date.now() - startTime;
                
                addTestResult('stress-results', '并发压力测试', true, 
                    `100个并发请求完成，总耗时: ${totalTime}ms`);
                
                // 内存压力测试
                const memoryBefore = performance.memory ? performance.memory.usedJSHeapSize : 0;
                
                for (let i = 0; i < 1000; i++) {
                    enhancedMemoryManager.addKey({
                        key: `stress-test-${i}`,
                        status: 'pending',
                        data: new Array(100).fill('test-data')
                    });
                }
                
                const memoryAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryIncrease = memoryAfter - memoryBefore;
                
                addTestResult('stress-results', '内存压力测试', true, 
                    `添加1000个密钥，内存增加: ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB`);
                
            } catch (error) {
                addTestResult('stress-results', '压力测试', false, `测试失败: ${error.message}`);
            }
        }

        // 内存泄漏测试
        async function runMemoryLeakTest() {
            const resultsContainer = document.getElementById('stress-results');
            
            if (!performance.memory) {
                addTestResult('stress-results', '内存泄漏测试', false, '浏览器不支持内存监控');
                return;
            }
            
            const initialMemory = performance.memory.usedJSHeapSize;
            
            // 创建和销毁大量对象
            for (let cycle = 0; cycle < 5; cycle++) {
                // 创建对象
                const objects = [];
                for (let i = 0; i < 1000; i++) {
                    objects.push({
                        id: i,
                        data: new Array(1000).fill(`cycle-${cycle}-item-${i}`),
                        timestamp: Date.now()
                    });
                }
                
                // 模拟处理
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // 清理
                objects.length = 0;
                
                // 强制垃圾回收（如果可用）
                if (window.gc) {
                    window.gc();
                }
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            const finalMemory = performance.memory.usedJSHeapSize;
            const memoryDiff = finalMemory - initialMemory;
            const memoryDiffMB = memoryDiff / 1024 / 1024;
            
            const hasLeak = memoryDiffMB > 10; // 超过10MB认为可能有泄漏
            
            addTestResult('stress-results', '内存泄漏测试', !hasLeak, 
                `内存变化: ${memoryDiffMB.toFixed(2)}MB ${hasLeak ? '(可能存在泄漏)' : '(正常)'}`);
        }

        // 页面加载完成后启动
        document.addEventListener('DOMContentLoaded', function() {
            captureConsoleOutput();
            console.log('优化模块Bug修复验证测试页面已加载');
            
            // 显示测试概述
            const overview = document.createElement('div');
            overview.className = 'test-section';
            overview.innerHTML = `
                <h2 class="test-header">测试概述</h2>
                <div class="test-info">
                    <strong>测试目标:</strong> 验证所有优化模块的bug修复效果<br>
                    <strong>测试范围:</strong> 6个核心优化模块 + 综合压力测试<br>
                    <strong>修复内容:</strong> 内存泄漏、错误处理、资源清理、兼容性问题<br>
                    <strong>状态:</strong> 准备就绪，点击各模块测试按钮开始验证
                </div>
            `;
            document.body.insertBefore(overview, document.body.firstChild.nextSibling);
        });
    </script>
</body>
</html>
